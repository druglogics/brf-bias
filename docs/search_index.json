[
["index.html", "Standaridized Boolean Regulatory Function Bias Input Libraries", " Standaridized Boolean Regulatory Function Bias John Zobolas Last updated: 05 October, 2020 Input Libraries library(gtools) library(dplyr) library(tibble) library(tidyr) library(usefun) library(foreach) library(doParallel) library(DT) library(ggplot2) library(ggpubr) library(corrplot) "],
["bbrs.html", "Balance Boolean Regulatory Functions (BBRs)", " Balance Boolean Regulatory Functions (BBRs) The BBRs (Balance Boolean Regulatory functions) functions have two sets of regulators: activators (on one side) and inhibitors (on the other). I have observed two main classes of these functions: one that uses logical rules to derive the combinatorial activity of the regulators and one that relies on the combined additive activity (via pseudo-boolean constrains). Let \\(f\\) be a boolean function \\(f(x,y):\\{0,1\\}^n \\rightarrow \\{0,1\\}\\), with \\(m\\) activators \\(x=\\{x_i\\}_{i=1}^{m}\\) and \\(k\\) inhibitors \\(y=\\{y_i\\}_{i=1}^{k}\\), that is a total of \\(n=m+k\\) regulators. The BBRs have a (non-DNF) representation that puts the different category regulators in 2 separate groups and a link boolean operator between them. As such, for a link operator to make sense, we have that \\(m,k \\ge 1\\) (at least one regulator in each category). An example of such a function that has been used in the literature (Mendoza and Xenarios 2006) is the formula with the AND-NOT link operator: AND-NOT: \\[f(x,y) = \\left(\\bigvee_{i=1}^{m} x_i\\right) \\land \\lnot \\left(\\bigvee_{i=1}^{k} y_i\\right)\\] A variant of that one that shifts the balance in favor of the activators (as we will see the truth density significantly increases) is the function with the OR-NOT link operator: OR-NOT: \\[f(x,y) = \\left(\\bigvee_{i=1}^{m} x_i\\right) \\lor \\lnot \\left(\\bigvee_{i=1}^{k} y_i\\right)\\] Another one of this type of functions is the next one: BalanceOp1: \\[f(x,y) = \\bigvee_{\\forall (i,j)}^{m,k}(x_i\\land \\lnot y_j) = \\left(\\bigvee_{i=1}^{m} x_i\\right) \\land \\left(\\bigvee_{i=1}^{k} \\lnot y_i\\right)\\] Next, we introduce the threshold functions which can be classified as pseudo-Boolean: exp_act_win: \\[f_{act-win}(x,y)=\\begin{cases} 1, &amp; \\text{for } \\sum_{i=1}^{m} x_i \\ge \\sum_{i=1}^{k} y_i\\\\ 0, &amp; \\text{otherwise} \\end{cases}\\] exp_inh_win: \\[f_{inh-win}(x,y)=\\begin{cases} 1, &amp; \\text{for } \\sum_{i=1}^{m} x_i \\gt \\sum_{i=1}^{k} y_i\\\\ 0, &amp; \\text{otherwise} \\end{cases}\\] Note that: \\(f_{inh-win}(x,y) = \\lnot f_{act-win}(y,x)\\). These functions are still categorized as BBRs, since they balance the additive activity of the activators and the inhibitors. I searched for an analytic formula for the two last functions. The equivalent boolean rule expressions become very large with more regulators but they always exist - which means that pretty much we are talking about the same kind of functions (the combinatorial vs additive distinction is a sugar for the theorists :)) More info and discussion about the last two formulas, see the math.stackexchange question. Somewhat similar function notations and definitions have been used in the work by (Cury, Monteiro, and Chaouiya 2019), where they used the equivalent DNF forms. "],
["truth-density-data-analysis.html", "Truth Density Data Analysis Data Truth Density formulas AND-NOT vs OR-NOT TD BalanceOp1 TD Threshold Functions TD TD Data Distance Correlation", " Truth Density Data Analysis Data Truth Density (TD) of a boolean equation/expression, given it’s equivalent truth table, is the number of rows that the expression is active divided to the total number of rows \\((2^n)\\). I created every possible truth table for up to \\(20\\) variables (variables here means regulators for us) and calculated the AND-NOT, OR-NOT, BalanceOp1, exp_act_win, exp_inh_win boolean function results for every possible configuration of the number of activators and inhibitors that added up to the number of regulators. Then, from the truth tables I calculated the truth density of each operator for each particular configuration. For more details see the script get_stats.R See part of the data below: stats = readRDS(file = &quot;data/td_stats.rds&quot;) DT::datatable(data = stats, caption = htmltools::tags$caption(&quot;Truth Density Data&quot;, style=&quot;color:#dd4814; font-size: 18px&quot;), options = list(pageLength = 6, scrollX = TRUE, order = list(list(1, &quot;asc&quot;)))) %&gt;% formatRound(4:8, digits = 2) Truth Density formulas Also, I have proved the exact formulas for the truth densities in the case of the AND-NOT and OR-NOT link operators (see here for a proof sketch). I write them here explicitly, as well as their long-term behavior (for large number of regulators \\(n\\)): AND-NOT: \\[TD_{AND-NOT}=\\frac{2^m-1}{2^n} \\xrightarrow{n \\text{ large}} \\frac{1}{2^k}\\] OR-NOT: \\[TD_{OR-NOT}=\\frac{2^n-2^k}{2^n} \\xrightarrow{n \\text{ large}} 1-\\frac{1}{2^m}\\] For large \\(n\\), the \\(TD_{AND-NOT}\\) depends only on the number of inhibitors while the \\(TD_{OR-NOT}\\) depends only on the number of activators. Also, again for large \\(n\\), the extreme case of having a TD value equal to \\(0.5\\) is a result of having only one of the regulators being an inhibitor (activator) of the AND-NOT (OR-NOT) equation. We can use the data above to validate the formulas from the proof (up to \\(n=20\\)): # Validate AND-NOT Truth Density formula formula_td_and_not = stats %&gt;% mutate(formula_td_and_not = (2^num_act - 1)/(2^num_reg)) %&gt;% pull(formula_td_and_not) all(stats %&gt;% pull(td_and_not) == formula_td_and_not) [1] TRUE # Validate OR-NOT Truth Density formula formula_td_or_not = stats %&gt;% mutate(formula_td_or_not = (((2^num_act - 1) * (2^num_inh)) + 1)/(2^num_reg)) %&gt;% pull(formula_td_or_not) all(stats %&gt;% pull(td_or_not) == formula_td_or_not) [1] TRUE AND-NOT vs OR-NOT TD Comparing the AND-NOT and OR-NOT truth densities across the number of regulators: # tidy up data stats_and_or = tidyr::pivot_longer(data = stats, cols = c(td_and_not, td_or_not), names_to = &quot;lo&quot;, values_to = &quot;td&quot;) %&gt;% select(num_reg, lo, td) %&gt;% mutate(lo = replace(x = lo, list = lo == &quot;td_and_not&quot;, values = &quot;AND-NOT&quot;)) %&gt;% mutate(lo = replace(x = lo, list = lo == &quot;td_or_not&quot;, values = &quot;OR-NOT&quot;)) %&gt;% rename(`Link Operator` = lo) ggboxplot(data = stats_and_or, x = &quot;num_reg&quot;, y = &quot;td&quot;, color = &quot;Link Operator&quot;, palette = &quot;Set1&quot;, title = &quot;AND-NOT vs OR-NOT Truth Densities&quot;, xlab = &quot;Number of regulators&quot;, ylab = &quot;Truth Density&quot;) + theme(plot.title = element_text(hjust = 0.5)) Figure 1: AND-NOT vs OR-NOT Truth Densities across all possible activators and inhibitors combinations up to 20 regulators The more regulators there are, the more likely it is that the AND-NOT link operator in the boolean equation will result in an inhibited target and that the OR-NOT link operator in an active target. For \\(n&gt;6\\), the points outside the boxplots (with a truth density of \\(\\frac{1}{2}, \\frac{1}{4}, 1-\\frac{1}{4},\\frac{1}{8},1-\\frac{1}{8},...\\)) correspond to the long-term behavior of the truth density formulas shown above where there is also large imbalance between the number of activators and inhibitors. We can also check the relation between TD and number of activators and inhibitors in each case. The following two figures show us why the number of inhibitors are more decisive in the AND-NOT case: ggscatter(data = stats %&gt;% rename(`#Regulators` = num_reg), x = &quot;num_inh&quot;, y = &quot;td_and_not&quot;, color = &quot;#Regulators&quot;, ylab = &quot;Truth Density&quot;, xlab = &quot;Number of Inhibitors&quot;, title = &quot;AND-NOT TD vs Number of Inhibitors&quot;) + theme(plot.title = element_text(hjust = 0.5)) ggscatter(data = stats %&gt;% rename(`#Regulators` = num_reg), x = &quot;num_act&quot;, y = &quot;td_and_not&quot;, color = &quot;#Regulators&quot;, ylab = &quot;Truth Density&quot;, xlab = &quot;Number of Activators&quot;, title = &quot;AND-NOT TD vs Number of Activators&quot;) + theme(plot.title = element_text(hjust = 0.5)) Figure 2: AND-NOT TD vs Number of Activators and Inhibitors In the OR-NOT case the number of activators is more important: ggscatter(data = stats %&gt;% rename(`#Regulators` = num_reg), x = &quot;num_inh&quot;, y = &quot;td_or_not&quot;, color = &quot;#Regulators&quot;, ylab = &quot;Truth Density&quot;, xlab = &quot;Number of Inhibitors&quot;, title = &quot;OR-NOT TD vs Number of Inhibitors&quot;) + theme(plot.title = element_text(hjust = 0.5)) ggscatter(data = stats %&gt;% rename(`#Regulators` = num_reg), x = &quot;num_act&quot;, y = &quot;td_or_not&quot;, color = &quot;#Regulators&quot;, ylab = &quot;Truth Density&quot;, xlab = &quot;Number of Activators&quot;, title = &quot;OR-NOT TD vs Number of Activators&quot;) + theme(plot.title = element_text(hjust = 0.5)) Figure 3: OR-NOT TD vs Number of Activators and Inhibitors BalanceOp1 TD If we add the BalanceOp1 TD results to the first plot we have: # tidy up data stats_and_or_balance = tidyr::pivot_longer(data = stats, cols = c(td_and_not, td_or_not, td_balance_op), names_to = &quot;lo&quot;, values_to = &quot;td&quot;) %&gt;% select(num_reg, lo, td) %&gt;% mutate(lo = replace(x = lo, list = lo == &quot;td_and_not&quot;, values = &quot;AND-NOT&quot;)) %&gt;% mutate(lo = replace(x = lo, list = lo == &quot;td_or_not&quot;, values = &quot;OR-NOT&quot;)) %&gt;% mutate(lo = replace(x = lo, list = lo == &quot;td_balance_op&quot;, values = &quot;BalanceOp1&quot;)) %&gt;% rename(`Link Operator` = lo) ggboxplot(data = stats_and_or_balance, x = &quot;num_reg&quot;, y = &quot;td&quot;, color = &quot;Link Operator&quot;, palette = &quot;Set1&quot;, title = &quot;AND-NOT vs OR-NOT vs BalanceOp1 Truth Densities&quot;, xlab = &quot;Number of regulators&quot;, ylab = &quot;Truth Density&quot;) + theme(plot.title = element_text(hjust = 0.5)) Figure 4: AND-NOT vs OR-NOT vs BalanceOp1 Truth Densities across all possible activators and inhibitors combinations up to 20 regulators The BalanceOp1 TD values are closer to the TD values of the OR-NOT formula compared to the AND-NOT one. The BalanceOp1 is less biased compared to the OR-NOT link operator, but still for large \\(n\\) (regulators) it practically makes the target activated. As we can see in the following two figures, the BalanceOp1 shows a more balanced dependency between the number of activators and inhibitors: ggscatter(data = stats %&gt;% rename(`#Regulators` = num_reg), x = &quot;num_inh&quot;, y = &quot;td_balance_op&quot;, color = &quot;#Regulators&quot;, ylab = &quot;Truth Density&quot;, xlab = &quot;Number of Inhibitors&quot;, title = &quot;BalanceOp1 TD vs Number of Inhibitors&quot;) + theme(plot.title = element_text(hjust = 0.5)) ggscatter(data = stats %&gt;% rename(`#Regulators` = num_reg), x = &quot;num_act&quot;, y = &quot;td_balance_op&quot;, color = &quot;#Regulators&quot;, ylab = &quot;Truth Density&quot;, xlab = &quot;Number of Activators&quot;, title = &quot;BalanceOp1 TD vs Number of Activators&quot;) + theme(plot.title = element_text(hjust = 0.5)) Figure 5: BalanceOp1 TD vs Number of Activators and Inhibitors Threshold Functions TD In contrast, if we check the truth density of the \\(f_{act-win}(x,y)\\) and \\(f_{inh-win}(x,y)\\) boolean functions we have: # tidy up data stats_functions = tidyr::pivot_longer(data = stats, cols = c(td_exp_act, td_exp_inh), names_to = &quot;fun&quot;, values_to = &quot;td&quot;) %&gt;% select(num_reg, fun, td) %&gt;% mutate(fun = replace(x = fun, list = fun == &quot;td_exp_act&quot;, values = &quot;Activators Win&quot;)) %&gt;% mutate(fun = replace(x = fun, list = fun == &quot;td_exp_inh&quot;, values = &quot;Inhibitors Win&quot;)) %&gt;% rename(`Equation Formula` = fun) ggboxplot(data = stats_functions, x = &quot;num_reg&quot;, y = &quot;td&quot;, color = &quot;Equation Formula&quot;, palette = &quot;lancet&quot;, title = latex2exp::TeX(&quot;Truth Densities of $f_{act-win}(x,y)$ and $f_{inh-win}(x,y)$&quot;), xlab = &quot;Number of regulators&quot;, ylab = &quot;Truth Density&quot;) + theme(plot.title = element_text(hjust = 0.5)) Figure 6: Truth Desities of two robust boolean formulas across all possible activators and inhibitors combinations up to 20 regulators Both boolean functions have a large variance of truth densities irrespective of the number of regulators. The median values seem to converge to \\(0.5\\) for both formulas. The median value of truth density for the \\(f_{act-win}(x,y)\\) is always larger than the \\(f_{inh-win}(x,y)\\) (as expected). TD Data Distance We check how close are the truth density values of the different proposed BBRs, also compared to the proportion of activators, e.g. if a BBR has 1 activator and 5 inhibitors (resp. 5 activators and 1 inhibitor) I would expect the boolean regulatory function’s output to be statistically more inhibited (resp. activated). We find the euclidean distance between the different truth density values and show them in a table and dendrogram format: act_prop = stats %&gt;% mutate(act_prop = num_act/num_reg) %&gt;% pull(act_prop) td_and_not = stats %&gt;% pull(td_and_not) td_or_not = stats %&gt;% pull(td_or_not) td_balance_op = stats %&gt;% pull(td_balance_op) td_exp_act = stats %&gt;% pull(td_exp_act) td_exp_inh = stats %&gt;% pull(td_exp_inh) d = dist(x = rbind(act_prop, td_and_not, td_or_not, td_balance_op, td_exp_act, td_exp_inh), method = &quot;euclidean&quot;) # color `act_prop` column breaks = quantile(unname(as.matrix(d)[, &quot;act_prop&quot;]), probs = seq(.05, .95, .05), na.rm = TRUE) col = round(seq(255, 40, length.out = length(breaks) + 1), 0) %&gt;% {paste0(&quot;rgb(255,&quot;, ., &quot;,&quot;, ., &quot;)&quot;)} # red caption.title = &quot;Euclidean Distances between vectors of truth density values (Symmetric)&quot; DT::datatable(data = d %&gt;% as.matrix(), options = list(dom = &quot;t&quot;, scrollX = TRUE), caption = htmltools::tags$caption(caption.title, style=&quot;color:#dd4814; font-size: 18px&quot;)) %&gt;% formatRound(1:6, digits = 3) %&gt;% formatStyle(columns = c(&quot;act_prop&quot;), backgroundColor = styleInterval(breaks, col)) plot(hclust(dist(d)), main = &quot;Distance Dendogram of Thruth Densities&quot;, ylab = &quot;Euclidean Distance&quot;, sub = &quot;&quot;, xlab = &quot;&quot;) The threshold functions have truth densities values that are closer to the proportion of activators for a varying number of regulators, compared to the AND-NOT and OR-NOT formulas. As such they might represent more realistic candidates for regulatory functions from a statistical point of view. The TD values of OR-NOT and BalanceOp1 are in general very close (as we’ve also seen in a previous figure) Correlation We will now check the correlation between each pair of operators/proposed functions, as well as the number of regulators, inhibitors and activators: M = cor(stats, method = &quot;kendall&quot;) res = corrplot::cor.mtest(stats, method = &quot;kendall&quot;) corrplot::corrplot(corr = M, type = &quot;upper&quot;, p.mat = res$p, sig.level = c(.001, .01, .05), pch.cex = 1, pch.col = &quot;white&quot;, insig = &quot;label_sig&quot;, tl.col = &quot;black&quot;, tl.srt = 45) Figure 7: Correlation Matrix of Truth Densities and number of regulators The two functions results \\(f_{act-win}(x,y), f_{inh-win}(x,y)\\) are highly correlated as expected Lower AND-NOT TD values highly correlate with higher number of inhibitors Higher OR-NOT TD values highly correlate with higher number of activators "],
["r-session-info.html", "R session info", " R session info xfun::session_info() R version 3.6.3 (2020-02-29) Platform: x86_64-pc-linux-gnu (64-bit) Running under: Ubuntu 18.04.5 LTS Locale: LC_CTYPE=en_US.UTF-8 LC_NUMERIC=C LC_TIME=en_US.UTF-8 LC_COLLATE=en_US.UTF-8 LC_MONETARY=en_US.UTF-8 LC_MESSAGES=en_US.UTF-8 LC_PAPER=en_US.UTF-8 LC_NAME=C LC_ADDRESS=C LC_TELEPHONE=C LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C Package version: abind_1.4-5 assertthat_0.2.1 backports_1.1.9 base64enc_0.1.3 BH_1.72.0.3 bookdown_0.20 boot_1.3.25 broom_0.7.0 callr_3.4.4 car_3.0-9 carData_3.0-4 cellranger_1.1.0 cli_2.0.2 clipr_0.7.0 codetools_0.2-16 colorspace_1.4-1 compiler_3.6.3 conquer_1.0.2 corrplot_0.84 cowplot_1.1.0 cpp11_0.2.1 crayon_1.3.4 crosstalk_1.1.0.1 curl_4.3 data.table_1.13.0 desc_1.2.0 digest_0.6.25 doParallel_1.0.15 dplyr_1.0.2 DT_0.15 ellipsis_0.3.1 evaluate_0.14 fansi_0.4.1 farver_2.0.3 forcats_0.5.0 foreach_1.5.0 foreign_0.8-75 generics_0.0.2 ggplot2_3.3.2 ggpubr_0.4.0 ggrepel_0.8.2 ggsci_2.9 ggsignif_0.6.0 glue_1.4.2 graphics_3.6.3 grDevices_3.6.3 grid_3.6.3 gridExtra_2.3 gtable_0.3.0 gtools_3.8.2 haven_2.3.1 highr_0.8 hms_0.5.3 htmltools_0.5.0 htmlwidgets_1.5.1 isoband_0.2.2 iterators_1.0.12 jsonlite_1.7.1 knitr_1.29 labeling_0.3 later_1.1.0.1 lattice_0.20.41 lazyeval_0.2.2 lifecycle_0.2.0 lme4_1.1.23 magrittr_1.5 maptools_1.0.2 markdown_1.1 MASS_7.3.53 Matrix_1.2.18 MatrixModels_0.4.1 matrixStats_0.56.0 methods_3.6.3 mgcv_1.8.33 mime_0.9 minqa_1.2.4 munsell_0.5.0 nlme_3.1.149 nloptr_1.2.2.2 nnet_7.3.14 openxlsx_4.1.5 parallel_3.6.3 pbkrtest_0.4.8.6 pillar_1.4.6 pkgbuild_1.1.0 pkgconfig_2.0.3 pkgload_1.1.0 polynom_1.4.0 praise_1.0.0 prettyunits_1.1.1 processx_3.4.4 progress_1.2.2 promises_1.1.1 ps_1.3.4 purrr_0.3.4 quantreg_5.67 R6_2.4.1 RColorBrewer_1.1.2 Rcpp_1.0.5 RcppArmadillo_0.9.900.3.0 RcppEigen_0.3.3.7.0 readr_1.3.1 readxl_1.3.1 rematch_1.0.1 rio_0.5.16 rlang_0.4.7 rmarkdown_2.3 rprojroot_1.3.2 rstatix_0.6.0 rstudioapi_0.11 scales_1.1.1 sp_1.4.2 SparseM_1.78 splines_3.6.3 statmod_1.4.34 stats_3.6.3 stringi_1.5.3 stringr_1.4.0 testthat_2.3.2 tibble_3.0.3 tidyr_1.1.2 tidyselect_1.1.0 tinytex_0.25 tools_3.6.3 usefun_0.4.8 utf8_1.1.4 utils_3.6.3 vctrs_0.3.4 viridisLite_0.3.0 withr_2.2.0 xfun_0.17 yaml_2.2.1 zip_2.1.1 "],
["references.html", "References", " References Cury, José E. R., Pedro T. Monteiro, and Claudine Chaouiya. 2019. “Partial Order on the set of Boolean Regulatory Functions,” January. http://arxiv.org/abs/1901.07623. Mendoza, Luis, and Ioannis Xenarios. 2006. “A method for the generation of standardized qualitative dynamical systems of regulatory networks.” Theoretical Biology and Medical Modelling 3 (1): 13. https://doi.org/10.1186/1742-4682-3-13. "]
]
